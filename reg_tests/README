---------------------------------------------------------------
HOW TO RUN THE REGRESSION TEST SUITE
---------------------------------------------------------------

The regression test suite consists of eight Fortran programs
that invoke a subset of IPOLATES (or IPLIB) routines.  IPOLATES
developers are required to run this test suite to ensure their
branch changes perform as expected before they are merged to 
the trunk.

The following steps are required to setup and run the test suite:

(1) Compile the 'test' and 'control' IPOLATES libraries.

   The suite tests all three precision versions of IPOLATES:

   -4 byte integer/4 byte float ("_4")
   -4 byte integer/8 byte float ("_d")
   -8 byte integer/8 byte float ("_8")

   The 'test' libraries are your branch copies, while 
   the 'control' libaries are the head of the trunk.

(2) Link the 'test' and 'control' IPOLATES libraries to the
    ./reg_tests/lib directory in your branch.  

    The regression test build expects the 'test' and 'control'
    libraries in the ./reg_tests/lib directory with the 
    following names:

    libip_ctl_4.a  (4 byte integer/4 byte float, control)
    libip_ctl_8.a  (8 byte integer/8 byte float, control)
    libip_ctl_d.a  (4 byte integer/8 byte float, control)
    libip_test_4.a  (4 byte integer/4 byte float, test)
    libip_test_8.a  (8 byte integer/8 byte float, test)
    libip_test_d.a  (4 byte integer/8 byte float, test)

    One way to place these libraries in the ./reg_tests/lib
    directory is thru unix links.  Suppose the trunk and
    branch libraries will built using an 'nco-style' installation.
    First, change to the ./reg_tests/lib directory:

    "cd /branch/reg_tests/lib"

    Then, link each library to the name expected by the regression
    test build:
    
    "ln -s /trunk/ip/vX.Y.Z/libip_vX.Y.Z_4.a  ./libip_ctl_4.a"
    "ln -s /trunk/ip/vX.Y.Z/libip_vX.Y.Z_8.a  ./libip_ctl_8.a"
    "ln -s /trunk/ip/vX.Y.Z/libip_vX.Y.Z_d.a  ./libip_ctl_d.a"
    "ln -s /branch/ip/vX.Y.Z/libip_vX.Y.Z_4.a ./libip_test_4.a"
    "ln -s /branch/ip/vX.Y.Z/libip_vX.Y.Z_8.a ./libip_test_8.a"
    "ln -s /branch/ip/vX.Y.Z/libip_vX.Y.Z_d.a ./libip_test_d.a"

(3) Check the ./reg_tests/config-setup/ifort.setup file in your branch.

    This file contains the compiler, compiler flags and link flags.
    Currently, the regression suite has only been tested with the
    intel "ifort" compiler.  Unless your machine does not have 
    the intel compiler, you should not have to change these
    settings.

(4) Ensure the build process can find the NCEP SP, W3NCO and
    BACIO libraries.

    The regression suite requires these external libraries.  The
    path/name of these libraries are stored in environment 
    variables in the "make_reg_tests.ksh" script. These variables are:
    
    SP_LIB4    - 4 byte integer/4 byte float version
    SP_LIB8    - 8 byte integer/8 byte float version
    SP_LIBd    - 4 byte integer/8 byte float version
    W3NCO_LIB4 - 4 byte integer/4 byte float version
    W3NCO_LIB8 - 8 byte integer/8 byte float version
    W3NCO_LIBd - 4 byte integer/8 byte float version
    BACIO_LIB4 - 4 byte integer/4 byte float version
    BACIO_LIB8 - 8 byte integer/8 byte float version

    There is no mixed precision ("_d") version of BACIO.

    On WCOSS and Zeus, these variables are set automatically by
    "make_reg_test.ksh" via modules.  There is no way to
    to override those settings except to manually edit 
    the "make_reg_tests.ksh" script.

    On other machines, the user must locate these libraries
    and manually set the environment variables on the command
    line before running "make_reg_tests.ksh".  

    Example (if using tcsh):

    setenv W3NCO_LIB4 $pathname/libw3nco_4.a
    setenv SP_LIB4 $pathname/libsp_4.a
    ... and so on ...

(5) Build the regression tests suite.

    From ./reg_tests type "make_reg_tests.ksh"

    Log output from the 'ctl' and 'test' builds will be in the
    config*log files.  There will be six executables for
    each individual regression test (one for each 'ctl' and 'test' library version).
    These executables will be located in the ./exec sub-directory for
    the regression test.  The source code is in the ./sorc sub-directory.

(6) Kickoff the regression test suite.

    There are driver scripts for WCOSS, Zeus and CCS located in
    ./reg_tests.  The CCS script is no longer used.  

    To start the tests on WCOSS, simply type the script name -
    Runall.wcoss.ksh - on the command line.  A series of
    "daisy-chained" jobs steps will be submitted.  To check
    the job queue type "bjobs".

    On Zeus, the "Runall.zeus.ksh" script is used.  Before running, 
    set the project code that will be charged when running the test
    suite.  The project code is script variable $PROJECT_CODE. The
    default is the "rm" project.  You may change the code by manually
    editing the script or doing "setenv PROJECT_CODE $code_name" on 
    the command line.  To find out which projects you
    are authorized to use, type "account_params".  After
    setting the project code, start the tests by typing
    "Runall.zeus.ksh" on the command line.  A series of
    "daisy-chained" jobs steps will be submitted.  To check
    the job queue, type: "showq -n -v -u USERNAME"
    
(7) Check results.

    On WCOSS, the default run directory is /stmpp1/${LOGNAME}/regression
    On Zeus, the default run directory is /scratch2/portfolios/NCEPDEV/stmp/$LOGNAME/regression
    (The run directory is variable $WORK_DIR in the driver script).

    Log output from the test suite will be in "regression.log"  To monitor as
    the suite is running, do: grep ">>>" regression.log
    
    Once the suite is complete, a summary is placed in "summary.log"   Any failures
    should be investigated.

---------------------------------------------------------------
DETAILS ON EACH INDIVIDUAL REGRESSION TEST
---------------------------------------------------------------

The tests in the following subdirectories are designed to test 
a subset of IPLIB.  It was too difficult to create a single test
that exercised every routine.  

1)  gausslat - A fortran program that calls routine gausslat 
    to calculate the gaussian latitudes for a t382 grid.
2)  gdswiz_wzd - A fortran program that calls gdswiz and gdswzd
    (and all of their child routines) to calculate lat/lon and
    other map-related fields for several grids of
    of various map projections.
3)  ipolates - A fortran program that interpolates a global
    lat/lon grid of substrate temperature to several grids of various
    projections using the ipolates suite of routines.  All
    interpolation options (bilinear, neighbor, etc.) are used.
4)  ipolatev - A fortran program that interpolates a global
    lat/lon grid of vector u/v wind to several grids of various
    projections using the ipolatev suite of routines.  All
    interpolation options (bilinear, neighbor, etc.) are used.
5)  ipxetas - A fortran program that reads a field of
    vegetation greenness on an unstaggered eta grid, then 
    calls routine ipxetas to do the following transforms:
      1) Create a staggered mass grid from the unstaggered grid.
      2) Create a staggered velocity grid from the unstaggered grid.
      3) Create an unstaggered grid from the staggered mass grid created by step (1)
      4) Create an unstaggered grid from the staggered vel grid created by step (2)
6)  ipxwafs2_3 - Test ip routines ipxwafs2 and ipxwafs3 by transforming
    a global grid of 600 mb temperature (on ncep grid 3) to wafs grids 37 thru 44 
    using copygb. After the global to wafs grid transforms are
    completed, copygb is invoked again to transform temperature data on each
    wafs grid back to ncep grid 3.  Note: routine ipxwafs2 is invoked 
    for interpolation option '0' (bilinear) and routine ipxwafs3 
    is invoked for interpolation option '2' (neighbor).
7)  ipxwafs - Same as experiment 9 except a specially modified version
    of copygb is used to call iplib routine ipxwafs instead of ipxwafs2. 
    ipxwafs and ipxwafs2 are the same except the latter accounts for bitmaps.
8)  makgds - A fortran program to test routine makgds.  Routine is called
    three times.
      1) Create gds and kgds arrays for ncep grid 3. these arrays hold grid
         description information used by w3 grib library.
      2) Make kgds array for grid 3 from gds array
      3) Make gds array for grid 3 from kgds array
9)  copygb - The ncep copygb program is used to transform a global lat/lon file of
    vegetation greenness to numerous standard ncep grids using all available
    interpolation options (bilinear, nearest neighbor, etc.).  Because this 
    test can take over an hour of wall clock time, and calls the same
    routines as other regression tests, it is not currently called
    from the regression driver scripts.  However, it may be run stand-alone.
    Note: The copygb executables are used by the ixpwafs2_3 regresion test.

Within each regression directory, the ./sorc subdirectory will contain the
source code and make-related files required for the regression test. A script
to run the individual regression test is under the ./scripts subdirectory.
The executables (after compilation) are stored under the ./exec subdirectory.
Any input data is stored in the ./data subdirectory.  Grads control files
to view any binary output data are stored in the ./grads subdirectory.  Some control
files do not have map backgrounds specified.  They are only used to
sanity check the data.  So when viewing, do a 'set mproj off'. 

More detailed information about each test is described in a README file in that
test's subdirectory.

Below is a table of each routine in iplib and which regression test(s) invoke it.

subroutine name         regression test
===============         ===============

gausslat                gausslat
gdswiz                  gdswiz_wzd, ipolates, ipolatev, ipxwafs, ipxwafs2_3, copygb
gdswiz00                gdswiz_wzd, ipolates, ipolatev, ipxwafs, ipxwafs2_3, copygb
gdswiz01                gdswiz_wzd, ipolates, ipolatev, copygb
gdswiz03                gdswiz_wzd, ipolates, ipolatev, copygb
gdswiz04                gdswiz_wzd, ipolates, ipolatev, copygb
gdswiz05                gdswiz_wzd, ipolates, ipolatev, copygb
gdswizc9                gdswiz_wzd
gdswizca                gdswiz_wzd
gdswizcb                gdswiz_wzd, ipolates, ipolatev, copygb
gdswizcd                gdswiz_wzd, ipolates, ipolatev, copygb
gdswzd                  gdswiz_wzd
gdswzd00                gdswiz_wzd
gdswzd01                gdswiz_wzd
gdswzd03                gdswiz_wzd
gdswzd04                gdswiz_wzd
gdswzd05                gdswiz_wzd
gdswzdc9                gdswiz_wzd
gdswzdca                gdswiz_wzd
gdswzdcb                gdswiz_wzd
gdswzdcd                gdswiz_wzd
ijkgds0                 ipolates, ipolatev, ipxwafs, ipxwafs2_3, copygb
ijkgds1                 ipolates, ipolatev, ipxwafs, ipxwafs2_3
ipolates                ipolates, ipxwafs, ipxwafs2_3, copygb
ipolatev                ipolatev
ipxetas                 ipxetas
ipxwafs                 ipxwafs, ipxwafs2_3
ipxwafs2                ipxwafs2_3, copygb
ipxwafs3                ipxwafs2_3, copygb
makgds                  ipxwafs, ipxwafs2_3, makgds
movect                  ipolatev
polates0                ipolates, ipxwafs, ipxwafs2_3, copygb
polates1                ipolates, copygb
polates2                ipolates, ipxwafs2_3, copygb
polates3                ipolates, copygb
polates4                ipolates, copygb
polates6                ipolates, copygb
polatev0                ipolatev
polatev1                ipolatev
polatev2                ipolatev
polatev3                ipolatev
polatev4                ipolatev
polatev6                ipolatev
polfixs                 ipolates, ipxwafs, ipxwafs2_3
polfixv                 ipolatev
